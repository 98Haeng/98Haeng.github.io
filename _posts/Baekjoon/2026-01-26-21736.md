---
title: "[Baekjoon] 21736 [헌내기는 친구가 필요해] 입맛대로 문제풀이"
excerpt: "백준 코딩테스트 문제인 21736, 헌내기는 친구가 필요해대한 입맛대로 문제풀이입니다."

categories:
  - Baekjoon
tags:
  - [Baekjoon]

permalink: /baekjoon/21736/

toc: true
toc_sticky: true

date: 2026-01-24
last_modified_at: 2026-01-24
---
### 카테고리
- 그래프 탐색 (BFS, DFS)

전형적인 그래프 탐색 문제인 "헌내기는 친구가 필요해" 문제입니다. 이 문제는 대표적인 BFS로 풀 수 있는 문제 중 하나라고 생각해서, BFS로 문제를 풀었습니다. <u>(DFS로 푼 버전은 추후 업로드 예정...) </u>



```python
import sys
from collections import deque
input = sys.stdin.readline

graphs = []
n, m = map(int, input().split())

# 그래프 만들기
for _ in range(n):
    maps = input().rstrip()
    infos = [char for char in maps]
    graphs.append(infos)
# start point
for i in range(n):
    for j in range(m):
        if graphs[i][j] == 'I':
            sx, sy = j, i

# print(graph)
# O : 빈공간, X : 벽, I : 도연, P : 사람
# bfs로 접근하는 것이 맞지 않을까...
def bfs(start_x, start_y):
    meet_count = 0
    ny = [-1, 1, 0, 0]
    nx = [0, 0, -1, 1]
    queue = deque()
    queue.append((start_y, start_x))
    visited = set()
    visited.add((start_y, start_x))

    while queue:
        y, x = queue.popleft()
        # 순회
        for i in range(4):
            new_x = x + nx[i]
            new_y = y + ny[i]

            if 0 <= new_y < n and 0 <= new_x < m:
                if (new_y, new_x) not in visited and graphs[new_y][new_x]!='X':
                    visited.add((new_y, new_x))
                    if graphs[new_y][new_x] == 'P':
                        meet_count += 1
                    queue.append((new_y, new_x))

    return meet_count

result = bfs(sx, sy)
if result == 0:
    print('TT')
else:
    print(result)
    
```

