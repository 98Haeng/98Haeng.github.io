---
title: "[Paper Review] Token-level Collaborative Alignment for LLM-based Generative Recommendation (WWW 2026)"
excerpt: "WWW 2026에서 공개된 TCA4Rec 논문에 대한 리뷰입니다."

categories:
  - recommend
tags:
  - [recommend]

permalink: /recommend/tca4rec/

toc: true
toc_sticky: true

date: 2026-02-23
last_modified_at: 2026-02-23
---

## Problem Statement

### Generative Recommendation
Generative Recommendation은 사용자가 이전에 상호작용한 아이템들을 토큰 단위로 변환해 LLM에 입력한 다음, 다음 상호작용할 아이템에 대한 토큰을 순차적으로 생성하게 하는 태스크입니다. 이 태스크에서는
- Input : 사용자의 이전 상호작용 아이템의 토큰 ID
- Output : 사용자가 다음에 상호작용할 아이템의 토큰 ID

다음과 같이 구성되어 있습니다.

### LLM-based Sequential Recommendation

LLM based Sequential Recommendation, LLM 기반의 순차 추천 모델은 사용자의 이전 상호작용 정보를 LLM에 입력하여 다음 아이템을 추천하는 방식을 말합니다. 보통 LLM 기반 추천은 순차 정보보다는 텍스트 정보에 의존하는 경향이 강한데, Cold-start에는 강력하지만, Warm-start에는 약한 문제점을 가지고 있습니다. 이 문제를 해결하기 위해, CF, 협업 신호를 LLM에 반영하는 방법들이 연구되어왔는데, 프롬프트에 반영하거나, learnable adapter을 반영해서 CF 정보를 반영하거나, Quantization을 활용해서 협업 정보를 활용하는 방법 들을 사용해왔습니다.

대표적인 모델로는 TALLRec, LLaRA, CoLLM, A-LLMRec 등이 있고, 해당 태스크에서는
- Input : 사용자가 이전 상호작용한 아이템의 Title (주로 Title을 사용합니다.)
- Output : 사용자가 다음에 상호작용할 아이템의 Title

다음과 같이 구성되어 있습니다. 보통, Title을 생성과정에서 많이 사용합니다.

## Previous Limitations

이 논문에서 지적하는 기존 연구의 한계는 다음과 같습니다.

찻쩨, LLM의 의미 공간과 협업 공간의 구조적 불일치 문제가 있습니다. LLM 기반 추천 연구에서, 협업, 즉 순차 정보를 반영하기 위해 Prompt나 Adapter 등으로 CF를 반영하는 등의 다양한 시도가 있어왔는데, 이는 multi-stage graining이나 curriculum training을 사용합니다. 이 경우, 학습 통제성이 떨어지고, 계산 과정에서 오버헤드가 발생하는 등의 문제가 있습니다.

둘째, RQ-VAE로 대표되는 numeric ID를 사용하게 되면 의미 재구성은 되지만, codebook이 아이템의 의미 유사도를 반영해버려 Collaborative 즉, 협업 정보를 반영하지 못하는 문제가 있습니다.이로 인해서 사용자 특화, 문맥에 의존하는 선호도 패턴이 약해지거나 추천에 필요한 CF 정렬이 제대로 되지 않는 문제가 발생합니다.

이러한 문제를 해결하기 위해, 저자들은 CF(협업) 신호를 LLM 생성 과정에 반영하는 것의 중요성을 언급하고, item-level의 선호도 정보를 어떻게 token-level 목적에 반영할지를 고민했습니다.


## Method : TCA4Rec (Token-level Collaborative Alignment for Recommendation)

<img width="708" height="418" alt="image" src="https://github.com/user-attachments/assets/0e6b37e1-7b9c-48b2-a826-1bd18acc3794" />

저자들은 이러한 문제를 해결하기 위해, TCA4Rec을 제안합니다. TCA4Rec은 CF 모델이 만든 item-level 선호도 정보(logit)를 LLM의 토큰 단위(next-token) 학습목표에 맞게 변환해 “soft label"로 주입함으로써, LLM 생성 추천을 CF 신호와 직접 정렬시키는 프레임워크입니다. 해당 모델은 일반적인 모델과 다르게, LLM based Recommendation 모델에 결합하여 사용하는 Plug-and-play 모델입니다.

이 모델에서 Input, Output은 다음과 같이 구성되어 있습니다.
- Input : 사용자의 과거에 상호작용한 아이템, 아이템 메타데이터
- Output : 사용자가 다음 상호작용할 아이템

여기서 사용되는 Next Token Prediction Loss는 다음과 같이 정의됩니다.


$$
\begin{aligned}
\mathcal{L}_{\mathrm{NTP}}
&= -\log P(t \mid x_u;\theta)
= -\sum_{j=1}^{|t|} \log P(y_j \mid x_u, y_{<j};\theta) \\
&= -\sum_{j=1}^{|t|} \log
\frac{\exp\!\big(f_\theta(y_j \mid x_u, y_{<j})\big)}
{\sum_{v\in\mathcal{V}} \exp\!\big(f_\theta(v \mid x_u, y_{<j})\big)} \\
&= -\sum_{j=1}^{|t|} \log
\frac{\sum_{v\in\mathcal{V}} \mathbf{1}_{v=y_j}\cdot \exp\!\big(f_\theta(v \mid x_u, y_{<j})\big)}
{\sum_{v\in\mathcal{V}} \exp\!\big(f_\theta(v \mid x_u, y_{<j})\big)}.
\end{aligned}
$$


이 과정에서 LLM의 기본 NTP Loss는 토큰별 Cross-entropy Loss로 사용됩니다. 수식에 나오는 주요 기호는 다음과 같습니다.
- $t$: 정답 토큰 시퀀스(예: 아이템을 나타내는 토큰열)
- $\text{|}t\text{|}$: 시퀀스 길이
- $x_u$: 사용자 입력(예: 과거 상호작용 기반 프롬프트)
- $y_j$: 정답 시퀀스의 $j$번째 토큰
- $y_{<j}$: $j$번째 토큰 이전까지의 토큰(prefix), 즉 $(y_1,\dots,y_{j-1})$
- $\theta$: 모델 파라미터
- $V$: LLM vocabulary(전체 토큰 집합)
- $f_\theta(v \mid x_u, y_{<j})$: 토큰 $v$에 대한 모델의 logit(점수)


첫번째 수식은 전체 시퀀스 확률을 토큰 단위로 분해하는 과정입니다. LLM은 자기회귀(autoregressive)방식으로 시퀀스를 생성하므로, 전체 시퀀스 확률은 다음과 같이 분해됩니다.

$$
P(t \mid x_u) = \prod_{j=1}^{|t|} P\big(y_j \mid x_u, y_{\lt j}\big)
$$

따라서 로그를 취하면 곱이 합으로 바뀌고, loss는 그 음수이므로 위와 같은 형태가 됩니다. 즉, **각 시점에서 “정답 다음 토큰”의 확률을 높이도록 학습**하는 구조입니다.

두번째 수식은 확률 $P(\cdot)$를 softmax로 풀어쓴 것입니다.

이 식에서, 모델은 각 토큰 $v\in V$에 대해 logit $f_\theta(v \mid \cdot)$을 출력하고, 이를 softmax로 정규화하여 확률분포로 만듭니다. 따라서 “정답 토큰 $y_j$”의 확률도 softmax 형태로 위처럼 표현됩니다.

마지막 식의 경우는, one-hot indicator로 정답 토큰만 선택하는 형태로 작성한 것입니다.
여기서 $\mathbf{1}_{v=y_j}$는 다음을 의미합니다.

- $v = y_j$이면 1
- 그렇지 않으면 0

따라서 위 합은 실제로는 정답 토큰 항만 남기고 나머지는 0이 되어 사라집니다.


### Collaborative Tokenizer
Collaborative Tokenizer은 CF가 만든 item-level logit/score를, LLM이 학습에 쓸 수 있는 LLM vocab 위 token-level 확률분포로 변환하는 과정입니다. 현재 생성된 prefix와 일치하는 후보 아이템만 남긴 뒤, 그 아이템 확률을 다음 토큰별로 합산해서 token 분포를 만드는 과정입니다.

이 과정에서 Input, Output은 
- Input : 사용자의 과거에 상호작용한 아이템 목록 (Ex, Title, Brand...)
- Output : Input 정보를 바탕으로 생성한 다음 토큰(=LLM vocab의 token id들)에 대한 확률분포

으로 구성되어 있습니다.

먼저, CF 모델(예: SASRec)에서 사용자 임베딩과 아이템 임베딩을 바탕으로 scoring function을 통해 아이템별 logit을 생성합니다. 일반적으로 dot product(내적)를 사용하며, 이는 다음과 같이 표현할 수 있습니다.

$z_{u,i} = g(e_u, e_i) = e_u^\top e_i$로 작성되는데, 이 $z_{u,i}$는 사용자 $u$가 아이템 $i$를 선호할 “점수(logit)”이며, 후보 아이템 간 상대적인 선호를 반영합니다.

다음으로, 각 아이템의 텍스트 표현(예: title)을 LLM tokenizer로 토큰화하여 item token sequence로 변환합니다.

$$t_i = (w_{i,1}, w_{i,2}, \dots, w_{i,|t_i|}), \quad w_{i,k} \in V$$

여기서 $w_{i,k}$는 LLM vocabulary $V$의 token id입니다.

이후 Intuitive grouping strategy를 사용해 CF logits를 token-level 확률분포로 재구성합니다. 구체적으로, 디코딩 step $j$에서 현재까지 생성된 prefix $y_{<j}$와 앞부분 토큰이 일치하는 아이템만 후보로 남깁니다.

$$C(y_{\lt j}) = \{\, i \in I \mid j \le |t_i|,\; (w_{i,1}, \ldots, w_{i,j-1}) = y_{\lt j} \,\}$$

즉, 현재 prefix를 “포함(일치)”하는 아이템만 다음 단계 후보로 인정합니다.

item logit $z_{u,i}$는 확률이 아니므로, 단순 합산하면 스케일 왜곡이 발생할 수 있습니다. 이를 방지하기 위해 **후보 집합 내부에서만 softmax**를 적용해 정규화된 item 확률을 만듭니다.

$$
\pi^{(j)}_{u,i} =
\frac{\exp(z_{u,i})}
{\sum_{k \in C(y_{\lt j})}\exp(z_{u,k})},
\quad i \in C(y_{\lt j})
$$

이때 다음이 성립합니다.

$$
\sum_{i \in C(y_{\lt j})} \pi^{(j)}_{u,i} = 1
$$

다음으로, 후보 아이템들의 확률을 **다음 토큰이 같은 것끼리** 합산하여 LLM vocab 위의 token-level 분포를 만듭니다.

$$
p_u(v \mid y_{<j}) =
\sum_{i \in C(y_{<j})} \pi^{(j)}_{u,i} \cdot \mathbf{1}[w_{i,j}=v],
\quad v \in V
$$

- $\mathbf{1}[w_{i,j}=v]$는 아이템 $i$의 $j$번째 토큰이 $v$이면 1, 아니면 0인 indicator입니다.
- 즉, “$j$번째 토큰이 $v$인 아이템들”의 확률을 모두 더해서 $v$의 확률을 만듭니다.

또한 각 아이템은 $j$번째 위치에 정확히 하나의 토큰을 가지므로, 전체 토큰 확률은 정상적으로 정규화됩니다.

$$
\sum_{v\in V} p_u(v \mid y_{\lt j})
= \sum_{i\in C(y_{\lt j})}\pi^{(j)}_{u,i}
= 1
$$


### Soft Label Alignment
Soft Label Alignment는 CT가 만든 token-level CF 분포를, 기존 NTP의 one-hot 정답 라벨과 섞어서 soft label을 만들고, 그걸로 LLM을 학습(파인튜닝)시키는 모듈입니다. 즉 CF 신호가 objective(손실함수) 레벨에서 LLM 업데이트에 직접 들어가게 하여 LLM Tokenizer에 CF 정보가 들어가도록 합니다.

- Input : 사용자의 과거에 상호작용한 아이템들의 Collaborative Tokenizer, LLM Tokenizer
- Output : 두 Tokenizer의 분포를 섞어 만든 soft-label (Soft NTP Loss)

디코딩 step $j$에서, Soft Label Alignment는 먼저 정답 next token $y_j$에 해당하는 one-hot 라벨과, Collaborative Tokenizer가 생성한 CF 기반 token-level 분포 $p_u(v \mid y_{<j})$를 준비합니다. 이후 두 정보를 혼합 계수 $\alpha \in [0,1]$를 사용해 결합하여 soft label을 구성합니다.

$$
\tilde{y}_j(v) = (1-\alpha)\,\mathbf{1}[v = y_j] + \alpha\, p_u(v \mid y_{\lt j})
$$

여기서 각 항의 의미는 다음과 같습니다.
- $\mathbf{1}[v=y_j]$: 정답 토큰 $y_j$에만 1을 주는 one-hot 라벨
- $p_u(v \mid y_{\lt j})$: CT가 만든 CF 기반 다음 토큰 분포
- $(1-\alpha)$: 정답(one-hot) 비중 (LLM 비중)
- $\alpha$: CF 분포 비중

즉, 기존 NTP처럼 “정답 토큰 하나만 맞추는” 방식이 아니라, 정답 토큰은 유지하면서도 CF 관점에서 그럴듯한 토큰들에도 확률 질량을 분배한 soft target을 사용하게 됩니다.

이제 LLM은 입력 $x_u$와 prefix $y_{\lt j}$를 바탕으로 다음 토큰에 대한 예측분포를 출력합니다.

$$
P_\theta(v \mid x_u, y_{\lt j})
$$

Soft Label Alignment에서는 이 예측분포가 위에서 만든 soft label $\tilde{y}_j(v)$와 정렬되도록 학습합니다. 즉, 학습 목표가 기존 one-hot 중심의 NTP에서 CF 신호가 반영된 soft-label 기반 학습 목표(Soft-NTP)로 바뀝니다.

정리하면, Soft Label Alignment는 정답 토큰을 맞추는 언어 모델의 기본 능력은 유지하면서, CF가 제공하는 협업 신호를 loss 수준에서 직접 반영하도록 합니다. 이로 인해서, LLM이 추천 문맥에서 더 협업 신호에 정렬되도록 업데이트합니다.

### Relation to Auxiliary KL Loss

해당 부분에서 비교 대상으로 사용하는 Auxiliary KL 방식은 기본 NTP Loss에 CF 기반 Token 분포를 타겟으로 하는 KL Loss입니다. 이 방식은 직관적으로 LLM 출력이 CF 분포를 닮도록 합니다. 
쉽게 설명하면, 고정된 soft label을 정답처럼 두고 Cross Entropy를 학습하는 것과 같습니다.
<img width="340" height="95" alt="image" src="https://github.com/user-attachments/assets/109f1b3c-dbde-4a4b-8e28-5374b226c923" />


하지만, 논문에서 제시하는 방법에서 Soft-NTP Loss는 log의 위치가 다릅니다. 확률 $P(v)$에 로그를 씌운 뒤 가중합을 계산하는데, Soft-NTP는 먼저 $\tilde{y}$와 P의 내적(합)을 만들고, 그 전체에 로그를 씌웁니다. 여기서 이 차이가 중요한 이유는, gradient 때문인데, Soft-NTP의 Gradient는 기존 Auxiliary KL Loss처럼 타겟이 고정된 것이 아닌, CF이자 정답 정보인 $\tilde{y}$와 현재 LLM의 예측 정보(P)가 함께 반영됩니다. 이로 인해, 둘 다 의존하는 target-like 분포가 된다고 논문에서는 이야기하고 있습니다.
<img width="220" height="47" alt="image" src="https://github.com/user-attachments/assets/0f89ffb6-7faf-42f9-8942-21d30a71b2a3" />


- CF/정답 정보인 $\tilde{y}$는 정답 one-hot + CT가 만든 CF token 분포를 섞은 라벨 정보(감독 신호)이고, $P$는 현재 LLM의 문맥으로부터 계산한 토큰 확률 정보입니다.

쉽게 말하면, Auxiliary KL의 경우는, CF가 말하는대로 따라가는 방식이고, Soft-NTP는 CF의 신호와 LLM의 현재 예측 상태를 함께 고려해 업데이트를 진행합니다. 그렇기에, Soft-NTP가 더 자연스럽게 LLM의 언어모델 성질과 결합된다고 봅니다.

## Experiments

### Experiments Settings

<img width="296" height="74" alt="image" src="https://github.com/user-attachments/assets/a0ac8ce9-cd67-4e25-a644-0bf942ecc673" />

논문의 실험에서는 Amazon Dataset의 Toys, Sports, Office 3개의 데이터를 사용합니다. 추가로, 5-core filtering 전략을 적용하며, Max sequence length는 10으로 설정합니다.

TCA4Rec은 LLM-based Recommendation 모델들에 결합하여 실험 성능을 평가합니다. 이 과정에서 train, valid, test를 8:1:1 비율로 구성하고, Backbone을 LLama3.2-3B로, 기본 추천 모델을 SASRec을 사용합니다. LLM 학습에 있어서는 LoRA 파인튜닝을 사용합니다.


### Overall Performance

<img width="732" height="316" alt="image" src="https://github.com/user-attachments/assets/31efde7e-b52a-4d0a-b823-8846f329ffb9" />

Amazon Toys/Sports/Office에서 다양한 베이스라인과 비교했을 때, TCA를 결합한 생성 추천 모델들이 HR/NDCG 지표에서 전반적으로 개선되는 경향을 보입니다. 이는 CF가 만든 item-level 선호도 신호를 토큰 단위 학습 목표에 맞춰 정렬했기 때문이라는 저자들은 논리를 뒷받침합니다. 즉 CF를 프롬프트 힌트나 표현 수준의 정보로만 제공하던 기존 방식보다, 학습 목적함수 수준에서 CF 신호가 직접 작동하도록 만든 점이 성능 향상의 핵심으로 제시하고 있습니다.

### Model-Agnostic Capability

<img width="336" height="131" alt="image" src="https://github.com/user-attachments/assets/4e95d751-1bda-4a8d-923f-56b2a7f88c62" />

해당 실험에서는 TCA의 성능 향상이 특정 모델 구조에만 국한된 것이 아님을 보여주기 위해, Quantization을 사용하는 Generative Recommendation 계열의 TIGER, LETTER 등에 TCA를 붙였을 때 성능이 함께 개선되는 결과를 보여줍니다. 여기서 공정성을 위해 Item semantic embedding으로는 LLama3.1-3b 모델을 사용했습니다. 

이 실험 결과로, TCARec의 3가지 데이터셋 모두에서 Semantic ID 기반 방법의 성능 역시 향상시킴을 보여줍니다. 이는 다양한 모델에 효과적으로 적용할 수 있음을 보여줍니다. 단, 공정한 조건을 위해 Semantic ID를 생성하는 것에 있어 Item의 title만 사용했기에, 제한된 성능을 보입니다. 추가로, LETTER의 경우, TIGER보다 더 좋은 성능을 보이는데, 이는 LETTER가 의미적 ID 생성 과정에서 협업 필터링 신호를 통합하여 더 높은 품질의 의미적 ID를 생성하고, 결과적으로 더 나은 추천 성능을 이끌어내기 때문입니다.


### Collaborative Consistency

<img width="731" height="259" alt="image" src="https://github.com/user-attachments/assets/9ac2a83d-cc72-413e-abe5-a4126abf0d94" />

성능이 좋아진 이유가 정말 CF 신호와 더 잘 정렬되었기 때문인지를 분석합니다. 여기에서는 CF 모델의 top-1 예측과 LLM 기반 추천 모델의 top-1 예측이 얼마나 일치하는지를 보는 Collaborative Consistency(CC) 지표를 정의하고, $\alpha$를 조절하면서 변화를 분석했습니다. 그 결과, $\alpha$가 커질수록 TCA가 LLM 예측을 CF 방향으로 정렬시키는 효과가 있지만, CC가 높아진다고 추천 성능이 계속 좋아지지는 않았습니다. CF 신호를 많이 반영할수록 정렬은 강해지지만, 과도하면 노이즈까지 반영해 성능이 떨어질 수 있으므로 LLM의 의미적 생성 능력과 CF 정렬 사이의 균형이 중요합니다.

### Ablation Study

<img width="339" height="110" alt="image" src="https://github.com/user-attachments/assets/3a8b21dc-fcef-4931-82dc-ec34d213293f" />

Collaborative Tokenizer(CT)와 Soft Label Alignment(SA)를 각각 제거한 후 성능 차이를 비교합니다. CT를 제거하고 나면, item-level CF 점수(선호도)를 token-level에 제대로 반영하지 못해 협업 신호가 약해저 성능이 감소하고, SA를 제거하고 대안으로 Auxiliary KL을 사용하면, baseline인 MSLqheksms rotjsehlwlaks, 모두 반영한 TCA보다는 성능이 낮게 도출됩니다.

### Efficiency of Incorporating CF Signals

<img width="737" height="196" alt="image" src="https://github.com/user-attachments/assets/ac3af494-7910-46df-9459-d21ad78d36fe" />

SASRec의 학습 데이터 양을 변화시키면서 수행할 때, small : 10K, medium : 50K, Large : Full size로 진행했습니다. 그 결과, CF 신호가 강해질수록 TCA 성능도 같이 상승하였고, CF 협업 지식을 효율적으로 흡수함을 알 수 있었습니다. 반대로, CoLLM은 CF 신호가 강해져도 제대로 활용하지 못하거나 오히려 떨어지는 것으로 보아, CF 신호 주입의 한계를 보여줍니다.

다음으로, SASRec대신, BERT4Rec을 사용한 성능도 함께 보여주는데, 강한/더 좋은 CF 모델에서 나온 신호일수록 TCA가 더 잘 작동하는지를 확인합니다. 여기서 알 수 있는 것은, 더 강한 CF 모델(품질이 좋은 모델)일수록, TCA가 이를 더 효과적으로 활용해서 성능 향상이 된다는 것이고, 반대로 CF 모델의 품질이 낮아지면 노이즈가 발생하는 등의 문제로 성능이 낮아질 수 있습니다.

## Conclusion

### Contribution
- CF 신호와 LLM 토큰 간의 불일치를 해소하며, 이를 Token-level에 반영했습니다.
- Plug-and-play 모델로, 다른 LLM이나 Generative Recommendation 모델에 결합하는 방식으로서, 활용가능성이 높습니다.

### Limitations
- LLM-based Recommendation 모델인데, CF 모델의 품질에 크게 의존하는 문제가 있습니다.
- 아이템 메타데이터 정보를 제대로 활용하는 것에 대한 언급이 없습니다. -> 만약 일부 정보만 사용한다면, 풍부한 텍스트 정보를 제대로 활용하지 못하는 것과 같습니다.
